<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backgammon - Single & Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background-image: url('https://images.pexels.com/photos/326311/pexels-photo-326311.jpeg');
            background-size: cover;
            background-position: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        /* Menu Screen Styles */
        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            max-width: 400px;
            width: 90%;
        }

        .menu-screen h1 {
            font-size: 3em;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            margin: 20px 0;
        }

        .menu-button {
            width: 100%;
            padding: 20px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .singleplayer-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .multiplayer-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .menu-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .menu-description {
            margin-top: 20px;
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.4;
        }

        /* Lobby Screen Styles */
        .lobby-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            max-width: 400px;
            width: 90%;
        }

        .lobby-screen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lobby-screen input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
        }

        .lobby-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin: 10px 0;
        }

        .lobby-buttons button {
            width: 100%;
            padding: 15px 20px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .find-opponent-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .find-opponent-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .cancel-search-btn {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .cancel-search-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .back-btn {
            background: linear-gradient(135deg, #666, #444);
            margin-top: 10px;
        }

        .lobby-status {
            margin: 20px 0;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 30px;
        }

        .waiting-animation {
            display: inline-block;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }

        /* Game Container Styles */
        .game-container {
            width: 100vw;
            height: 100vh;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            max-width: 500px;
        }

        .game-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 10px 20px;
            width: 100%;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .current-player {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 10px 0;
        }

        .die {
            width: 45px;
            height: 45px;
            background: #fff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .die.rolling {
            animation: roll 0.5s ease-in-out;
        }

        @keyframes roll {
            0% {
                transform: rotate(0deg) scale(1);
            }

            50% {
                transform: rotate(360deg) scale(1.2);
            }

            100% {
                transform: rotate(720deg) scale(1);
            }
        }

        .board-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            position: relative;
        }

        .board-container {
            position: relative;
            width: 95vw;
            max-width: 450px;
            aspect-ratio: 1 / 1.3;
            background: #8b6914;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 6px solid #5a420d;
        }

        .board {
            position: absolute;
            inset: 5px;
            display: grid;
            grid-template-columns: repeat(6, 1fr) 30px repeat(6, 1fr);
            grid-template-rows: 1fr 1fr;
            gap: 2px;
        }

        .bar {
            grid-column: 7;
            background: #5a420d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 5px 0;
        }

        .point {
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
        }

        .point.top {
            align-items: flex-start;
            flex-direction: column-reverse;
        }

        .point.bottom {
            align-items: flex-end;
            flex-direction: column;
        }

        .point::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            left: 50%;
            transform: translateX(-50%);
        }

        .point.top::before {
            top: 0;
            border-width: 0 20px 80px 20px;
        }

        .point.bottom::before {
            bottom: 0;
            border-width: 80px 20px 0 20px;
        }

        .point:nth-child(odd)::before {
            border-color: #d2691e transparent;
        }

        .point:nth-child(even)::before {
            border-color: #8b4513 transparent;
        }

        .point.top:nth-child(odd)::before {
            border-color: transparent transparent #d2691e transparent;
        }

        .point.top:nth-child(even)::before {
            border-color: transparent transparent #8b4513 transparent;
        }

        .point.valid-move {
            background: rgba(0, 255, 0, 0.3);
        }

        .point.selected {
            background: rgba(255, 255, 0, 0.3);
        }

        .checker {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            position: relative;
            margin: 1px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1;
            flex-shrink: 0;
        }

        .checker.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .checker.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            border: 1px solid #222;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .checker.draggable {
            cursor: grab;
        }

        .checker.draggable:active {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 100;
        }

        .home {
            position: absolute;
            width: 70px;
            height: 45%;
            background: #2c1810;
            border: 3px solid #8b6914;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            overflow: hidden;
        }

        .home.white {
            right: -80px;
            bottom: 5%;
            background: linear-gradient(180deg, #f5f5dc 0%, #e8e8d0 100%);
            border-color: #8b6914;
        }

        .home.black {
            right: -80px;
            top: 5%;
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border-color: #ccc;
        }

        .home:hover {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            transform: scale(1.05);
        }

        .home.valid-move {
            box-shadow: 0 0 25px #4CAF50;
            border-color: #4CAF50;
            animation: homePulse 1.5s infinite;
        }

        @keyframes homePulse {

            0%,
            100% {
                box-shadow: 0 0 25px #4CAF50;
                border-color: #4CAF50;
            }

            50% {
                box-shadow: 0 0 35px #4CAF50;
                border-color: #66ff66;
            }
        }

        .home-label {
            font-size: 11px;
            font-weight: bold;
            color: #8b6914;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-align: center;
        }

        .home.white .home-label {
            color: #333;
        }

        .home.black .home-label {
            color: #ddd;
        }

        .home-count {
            font-size: 22px;
            font-weight: bold;
            margin-top: auto;
            text-align: center;
        }

        .home.white .home-count {
            color: #333;
        }

        .home.black .home-count {
            color: #ddd;
        }

        .home-checkers {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-end;
            gap: 2px;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex: 1;
            min-width: 100px;
            max-width: 150px;
        }

        button:active:not(:disabled) {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2em;
            z-index: 1000;
            animation: popIn 0.3s ease-out;
            text-align: center;
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .counter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
        }

        .connection-status.connected {
            background: rgba(0, 255, 0, 0.8);
            color: #000;
        }

        .connection-status.disconnected {
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
        }

        @media (max-height: 700px) {
            .board-container {
                aspect-ratio: 1 / 1.1;
            }

            .point::before {
                border-width: 0 15px 60px 15px;
            }

            .point.top::before {
                border-width: 60px 15px 0 15px;
            }
        }

        @media (max-width: 380px) {
            .checker {
                width: 22px;
                height: 22px;
            }

            button {
                font-size: 14px;
                padding: 10px 15px;
            }
        }
    </style>
</head>

<body>
    <!-- Main Menu Screen -->
    <div class="menu-screen" id="menuScreen">
        <h1>üé≤ Backgammon</h1>

        <div class="menu-buttons">
            <button class="menu-button singleplayer-btn" id="singleplayerBtn">
                üéØ Einzelspieler
            </button>
            <button class="menu-button multiplayer-btn" id="multiplayerBtn">
                üåê Mehrspieler Online
            </button>
        </div>

        <div class="menu-description">
            <p><strong>Einzelspieler:</strong> Spiele lokal gegen einen Freund auf demselben Ger√§t</p>
            <p><strong>Mehrspieler:</strong> Spiele online gegen andere Spieler weltweit</p>
        </div>
    </div>

    <!-- Multiplayer Lobby Screen -->
    <div class="lobby-screen" id="lobbyScreen">
        <h1>üé≤ Online Lobby</h1>
        <input type="text" id="playerName" placeholder="Dein Name eingeben..." maxlength="20">

        <div class="lobby-buttons">
            <button class="find-opponent-btn" id="findOpponentBtn">üîç Finde Gegner</button>
            <button class="cancel-search-btn" id="cancelSearchBtn" style="display: none;">‚ùå Suche abbrechen</button>
            <button class="back-btn" id="backToMenuBtn">‚Üê Zur√ºck zum Men√º</button>
        </div>

        <div class="lobby-status" id="lobbyStatus"></div>

        <div style="margin-top: 20px; font-size: 0.9em; color: #ccc;">
            <p>üí° Tipp: Teile diese URL mit Freunden f√ºr Multiplayer!</p>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer">
        <div class="connection-status" id="connectionStatus" style="display: none;">Verbunden</div>

        <div class="game-info">
            <div class="player-info" id="playerInfo">
                <span id="whitePlayerName">Wei√ü</span>
                <span id="blackPlayerName">Schwarz</span>
            </div>
            <div class="current-player" id="currentPlayer">Warten auf Spiel...</div>
            <div class="dice-container">
                <div class="die" id="die1">-</div>
                <div class="die" id="die2">-</div>
            </div>
            <div id="moveInfo" style="font-size: 0.9em; margin-top: 5px;"></div>
        </div>

        <div class="board-wrapper">
            <div class="board-container">
                <div class="board" id="board"></div>
                <div class="home white" id="homeWhite">
                    <div class="home-label">Ziel Wei√ü</div>
                    <div class="home-count">0</div>
                </div>
                <div class="home black" id="homeBlack">
                    <div class="home-label">Ziel Schwarz</div>
                    <div class="home-count">0</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="gameMenuBtn">Men√º</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        class BackgammonApp {
            constructor() {
                this.gameMode = null; // 'single' or 'multiplayer'
                this.singlePlayerGame = null;
                this.multiPlayerGame = null;

                this.setupMenuEvents();
                this.showMenu();
            }

            setupMenuEvents() {
                document.getElementById('singleplayerBtn').addEventListener('click', () => {
                    this.startSinglePlayer();
                });

                document.getElementById('multiplayerBtn').addEventListener('click', () => {
                    this.showMultiplayerLobby();
                });

                document.getElementById('backToMenuBtn').addEventListener('click', () => {
                    this.showMenu();
                });

                document.getElementById('gameMenuBtn').addEventListener('click', () => {
                    this.showMenu();
                });
            }

            showMenu() {
                document.getElementById('menuScreen').style.display = 'flex';
                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'flex';

                // Cleanup games
                if (this.multiPlayerGame && this.multiPlayerGame.socket) {
                    this.multiPlayerGame.socket.disconnect();
                }
                this.gameMode = null;
                this.singlePlayerGame = null;
                this.multiPlayerGame = null;
            }

            startSinglePlayer() {
                this.gameMode = 'single';
                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'none';

                // Initialize single player game
                this.singlePlayerGame = new SinglePlayerBackgammon();
            }

            showMultiplayerLobby() {
                this.gameMode = 'multiplayer';
                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('lobbyScreen').style.display = 'flex';
                document.getElementById('gameContainer').style.display = 'none';

                // Initialize multiplayer game
                this.multiPlayerGame = new MultiplayerBackgammon(this);
            }

            showMultiplayerGame() {
                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                document.getElementById('connectionStatus').style.display = 'block';
                document.getElementById('playerInfo').style.display = 'flex';
            }
        }

        // Single Player Game Class
        class SinglePlayerBackgammon {
            constructor() {
                this.board = Array(24).fill(null).map(() => []);
                this.bar = { white: 0, black: 0 };
                this.home = { white: 0, black: 0 };
                this.currentPlayer = 'white';
                this.dice = [];
                this.availableMoves = [];
                this.selectedPoint = null;
                this.hasRolled = false;
                this.movesMade = 0;
                this.touchStartPoint = null;
                this.gameOver = false;

                this.initializeBoard();
                this.setupEventListeners();
                this.render();
                this.updateCurrentPlayer();
            }

            initializeBoard() {
                // Standard Backgammon Startposition
                this.board[0] = ['white', 'white'];
                this.board[5] = ['black', 'black', 'black', 'black', 'black'];
                this.board[7] = ['black', 'black', 'black'];
                this.board[11] = ['white', 'white', 'white', 'white', 'white'];
                this.board[12] = ['black', 'black', 'black', 'black', 'black'];
                this.board[16] = ['white', 'white', 'white'];
                this.board[18] = ['white', 'white', 'white', 'white', 'white'];
                this.board[23] = ['black', 'black'];

                // Initialize home areas with labels and counters
                const homeWhite = document.getElementById('homeWhite');
                const homeBlack = document.getElementById('homeBlack');

                if (homeWhite) {
                    homeWhite.innerHTML = '<div class="home-label">Ziel Wei√ü</div><div class="home-count">0</div>';
                }
                if (homeBlack) {
                    homeBlack.innerHTML = '<div class="home-label">Ziel Schwarz</div><div class="home-count">0</div>';
                }
            }

            setupEventListeners() {
                // Touch Events f√ºr bessere Mobile-Unterst√ºtzung
                document.getElementById('board').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touchStartPoint = this.getPointFromTouch(touch);
                }, { passive: false });

                document.getElementById('board').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.touchStartPoint !== null) {
                        this.handlePointClick(this.touchStartPoint);
                        this.touchStartPoint = null;
                    }
                }, { passive: false });

                // Mouse Events als Fallback
                document.getElementById('board').addEventListener('click', (e) => {
                    const point = this.getPointFromClick(e);
                    if (point !== null) {
                        this.handlePointClick(point);
                    }
                });
            }

            getPointFromTouch(touch) {
                const board = document.getElementById('board');
                const rect = board.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const points = board.querySelectorAll('.point');
                for (let i = 0; i < points.length; i++) {
                    const pointRect = points[i].getBoundingClientRect();
                    if (x >= pointRect.left - rect.left &&
                        x <= pointRect.right - rect.left &&
                        y >= pointRect.top - rect.top &&
                        y <= pointRect.bottom - rect.top) {
                        return parseInt(points[i].dataset.point);
                    }
                }
                return null;
            }

            getPointFromClick(e) {
                const point = e.target.closest('.point');
                if (point) {
                    return parseInt(point.dataset.point);
                }
                return null;
            }

            rollDice() {
                if (this.hasRolled) return;

                const die1 = document.getElementById('die1');
                const die2 = document.getElementById('die2');

                die1.classList.add('rolling');
                die2.classList.add('rolling');

                setTimeout(() => {
                    const roll1 = Math.floor(Math.random() * 6) + 1;
                    const roll2 = Math.floor(Math.random() * 6) + 1;

                    this.dice = roll1 === roll2 ? [roll1, roll1, roll1, roll1] : [roll1, roll2];
                    this.availableMoves = [...this.dice];
                    this.hasRolled = true;

                    die1.textContent = roll1;
                    die2.textContent = roll2;
                    die1.classList.remove('rolling');
                    die2.classList.remove('rolling');

                    this.updateMoveInfo();
                    this.updateButtons();

                    if (roll1 === roll2) {
                        this.showMessage(`Pasch! ${roll1}er Pasch gew√ºrfelt!`);
                    }

                    // Debug: Log available moves and check
                    console.log('Available moves:', this.availableMoves);
                    console.log('Has valid moves:', this.hasAnyValidMoves());

                    // In multiplayer mode, let the server handle automatic turn ending
                    if (this.socket) {
                        // Server will handle turn ending automatically when no moves are available
                        return;
                    }

                    // Only show "no moves" after a slight delay to ensure everything is set up (single-player only)
                    setTimeout(() => {
                        if (!this.hasAnyValidMoves() && this.availableMoves.length > 0) {
                            this.showMessage('Keine Z√ºge m√∂glich! Zug wird automatisch beendet.');
                            setTimeout(() => this.endTurn(), 2000);
                        }
                    }, 100);
                }, 500);
            }

            canBearOff(player) {
                const homeStart = player === 'white' ? 18 : 0;
                const homeEnd = player === 'white' ? 24 : 6;

                // Check bar
                if (this.bar[player] > 0) return false;

                for (let i = 0; i < 24; i++) {
                    if ((player === 'white' && i < homeStart) ||
                        (player === 'black' && i >= homeEnd)) {
                        if (this.board[i].some(checker => checker === player)) {
                            return false;
                        }
                    }
                }

                return true;
            }

            getValidMoves(fromPoint) {
                const validMoves = [];
                const player = this.currentPlayer;

                if (this.bar[player] > 0) {
                    if (fromPoint !== 'bar') return [];

                    for (const move of this.availableMoves) {
                        const targetPoint = player === 'white' ? 24 - move : move - 1;
                        if (this.canMoveTo(targetPoint, player)) {
                            validMoves.push(targetPoint);
                        }
                    }
                    return validMoves;
                }

                if (fromPoint === 'bar') return [];

                const direction = player === 'white' ? 1 : -1;

                for (const move of this.availableMoves) {
                    const targetPoint = fromPoint + (move * direction);

                    if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, player)) {
                        validMoves.push(targetPoint);
                    }

                    if (this.canBearOff(player)) {
                        const exactDistance = player === 'white' ? 24 - fromPoint : fromPoint + 1;

                        for (const move of this.availableMoves) {
                            if (move === exactDistance) {
                                validMoves.push('home');
                                break;
                            }
                            // Can use higher die if no checkers further back
                            else if (move > exactDistance) {
                                let canUseHigherDie = true;
                                const startCheck = player === 'white' ? fromPoint + 1 : 0;
                                const endCheck = player === 'white' ? 24 : fromPoint - 1;

                                for (let i = startCheck; player === 'white' ? i < endCheck : i <= endCheck; i++) {
                                    if (this.board[i].some(checker => checker === player)) {
                                        canUseHigherDie = false;
                                        break;
                                    }
                                }

                                if (canUseHigherDie) {
                                    validMoves.push('home');
                                    break;
                                }
                            }
                        }
                    }
                }

                return validMoves;
            }

            canMoveTo(point, player) {
                if (point < 0 || point >= 24) return false;
                const pointCheckers = this.board[point];
                if (pointCheckers.length === 0) return true;
                if (pointCheckers[0] === player) return true;
                if (pointCheckers.length === 1) return true; // Can hit single opponent checker
                return false;
            }

            makeMove(from, to, dieValue = null) {
                const player = this.currentPlayer;
                let moveDistance;

                if (from === -1) { // Moving from bar
                    this.bar[player]--;

                    // Hit opponent if single checker
                    if (this.board[to].length === 1 && this.board[to][0] !== player) {
                        const hitChecker = this.board[to][0];
                        this.board[to] = []; // Remove opponent checker
                        this.bar[hitChecker]++; // Add to opponent's bar
                        this.showMessage(`${hitChecker === 'white' ? 'Wei√üer' : 'Schwarzer'} Stein geschlagen!`);
                    }

                    this.board[to].push(player);
                    moveDistance = dieValue;
                } else if (to === 'home') {
                    const checker = this.board[from].pop();
                    this.home[player]++;

                    // Calculate actual distance for bear off
                    const actualDistance = player === 'white' ? 24 - from : from + 1;

                    // Use exact die or find higher die that can be used
                    if (dieValue && this.availableMoves.includes(dieValue)) {
                        moveDistance = dieValue;
                    } else {
                        // Find minimum suitable die
                        moveDistance = this.availableMoves.find(die => die >= actualDistance) || actualDistance;
                    }

                    if (this.home[player] === 15) {
                        setTimeout(() => {
                            this.showMessage(`${player === 'white' ? 'Wei√ü' : 'Schwarz'} hat gewonnen! üéâ`);
                            this.gameOver = true;
                            this.updateButtons();
                        }, 500);
                    }
                } else {
                    const checker = this.board[from].pop();

                    if (this.board[to].length === 1 && this.board[to][0] !== player) {
                        const hitChecker = this.board[to][0];
                        this.board[to] = []; // Remove opponent checker
                        this.bar[hitChecker]++; // Add to opponent's bar
                        this.showMessage(`${hitChecker === 'white' ? 'Wei√üer' : 'Schwarzer'} Stein geschlagen!`);
                    }

                    this.board[to].push(checker);
                    moveDistance = dieValue || Math.abs(to - from);
                }

                const moveIndex = this.availableMoves.indexOf(moveDistance);
                if (moveIndex > -1) {
                    this.availableMoves.splice(moveIndex, 1);
                }

                this.movesMade++;
                this.selectedPoint = null;
                this.clearHighlights();
                this.render();
                this.updateMoveInfo();

                if (this.availableMoves.length === 0) {
                    // All dice used
                    if (this.socket) {
                        // Server will handle turn ending automatically
                        this.showMessage('Alle W√ºrfel verwendet. Zug wird beendet.');
                    } else {
                        // End turn automatically in single-player mode
                        setTimeout(() => this.endTurn(), 1000);
                    }
                } else if (!this.hasAnyValidMoves()) {
                    // No more valid moves possible
                    if (this.socket) {
                        // Server will handle turn ending automatically
                        this.showMessage('Keine weiteren Z√ºge m√∂glich!');
                    } else {
                        // End turn automatically in single-player mode
                        setTimeout(() => {
                            this.showMessage('Keine weiteren Z√ºge m√∂glich!');
                            setTimeout(() => this.endTurn(), 1500);
                        }, 500);
                    }
                }
            }

            highlightValidMoves(fromPoint) {
                this.clearHighlights();

                // Highlight selected point
                const pointEl = document.querySelector(`[data-point="${fromPoint}"]`);
                if (pointEl) {
                    pointEl.classList.add('selected');
                }

                // Highlight valid destination points
                if (fromPoint === -1) { // From bar
                    for (const move of this.availableMoves) {
                        const targetPoint = this.currentPlayer === 'white' ? 24 - move : move - 1;
                        if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, this.currentPlayer)) {
                            const targetEl = document.querySelector(`[data-point="${targetPoint}"]`);
                            if (targetEl) targetEl.classList.add('valid-move');
                        }
                    }
                } else {
                    const direction = this.currentPlayer === 'white' ? 1 : -1;

                    for (const move of this.availableMoves) {
                        const targetPoint = fromPoint + (move * direction);

                        // Regular moves
                        if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, this.currentPlayer)) {
                            const targetEl = document.querySelector(`[data-point="${targetPoint}"]`);
                            if (targetEl) targetEl.classList.add('valid-move');
                        }

                        // Bearing off
                        if (this.checkCanBearOff()) {
                            const exactDistance = this.currentPlayer === 'white' ? 24 - fromPoint : fromPoint + 1;

                            if (move === exactDistance) {
                                const homeEl = document.getElementById(this.currentPlayer === 'white' ? 'homeWhite' : 'homeBlack');
                                if (homeEl) homeEl.classList.add('valid-move');
                            }
                            // Can use higher die if no checkers further back
                            else if (move > exactDistance) {
                                let canUseHigherDie = true;
                                const startCheck = this.currentPlayer === 'white' ? fromPoint + 1 : 0;
                                const endCheck = this.currentPlayer === 'white' ? 24 : fromPoint - 1;

                                for (let i = startCheck; this.currentPlayer === 'white' ? i < endCheck : i <= endCheck; i++) {
                                    if (this.board[i].some(checker => checker === this.currentPlayer)) {
                                        canUseHigherDie = false;
                                        break;
                                    }
                                }

                                if (canUseHigherDie) {
                                    const homeEl = document.getElementById(this.currentPlayer === 'white' ? 'homeWhite' : 'homeBlack');
                                    if (homeEl) homeEl.classList.add('valid-move');
                                }
                            }
                        }
                    }
                }
            }

            highlightBarEntryPoints() {
                this.clearHighlights();

                for (const move of this.availableMoves) {
                    const targetPoint = this.currentPlayer === 'white' ? 24 - move : move - 1;
                    if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, this.currentPlayer)) {
                        const targetEl = document.querySelector(`[data-point="${targetPoint}"]`);
                        if (targetEl) targetEl.classList.add('valid-move');
                    }
                }
            }

            clearHighlights() {
                document.querySelectorAll('.point, .home').forEach(el => {
                    el.classList.remove('selected', 'valid-move');
                });
            }

            hasAnyValidMoves() {
                if (this.bar[this.currentPlayer] > 0) {
                    // Must enter from bar first
                    for (const move of this.availableMoves) {
                        const targetPoint = this.currentPlayer === 'white' ? 24 - move : move - 1;
                        if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, this.currentPlayer)) {
                            return true;
                        }
                    }
                    return false;
                }

                for (let i = 0; i < 24; i++) {
                    if (this.board[i].length > 0 && this.board[i][this.board[i].length - 1] === this.currentPlayer) {
                        const direction = this.currentPlayer === 'white' ? 1 : -1;

                        for (const move of this.availableMoves) {
                            const targetPoint = i + (move * direction);

                            // Regular move
                            if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, this.currentPlayer)) {
                                return true;
                            }

                            // Bearing off
                            if (this.canBearOff(this.currentPlayer)) {
                                const exactDistance = this.currentPlayer === 'white' ? 24 - i : i + 1;
                                if (move === exactDistance) {
                                    return true;
                                }
                                // Can use higher die if no checkers further back
                                if (move > exactDistance) {
                                    let canUseHigherDie = true;
                                    const startCheck = this.currentPlayer === 'white' ? i + 1 : 0;
                                    const endCheck = this.currentPlayer === 'white' ? 24 : i - 1;

                                    for (let j = startCheck; this.currentPlayer === 'white' ? j < endCheck : j <= endCheck; j++) {
                                        if (this.board[j].some(checker => checker === this.currentPlayer)) {
                                            canUseHigherDie = false;
                                            break;
                                        }
                                    }

                                    if (canUseHigherDie) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }

                return false;
            }

            handlePointClick(pointIndex) {
                if (!this.hasRolled || this.gameOver) return;

                // Check if player has checkers on bar - BUT only if not already moving from bar
                if (this.bar[this.currentPlayer] > 0 && this.selectedPoint !== -1) {
                    this.showMessage('Zuerst m√ºssen Steine von der Bar eingew√ºrfelt werden!');
                    return;
                }

                if (this.selectedPoint === null) {
                    // Select a checker - only if it belongs to current player
                    if (this.board[pointIndex].length > 0 &&
                        this.board[pointIndex][this.board[pointIndex].length - 1] === this.currentPlayer) {

                        // Check if this point has valid moves before selecting
                        const validMoves = this.getValidMoves(pointIndex);
                        if (validMoves.length === 0) {
                            this.showMessage('Keine g√ºltigen Z√ºge von diesem Punkt m√∂glich!');
                            return;
                        }

                        this.selectedPoint = pointIndex;
                        this.highlightValidMoves(pointIndex);
                    } else {
                        this.showMessage('Du kannst nur deine eigenen Steine bewegen!');
                    }
                } else if (this.selectedPoint === pointIndex) {
                    // Deselect
                    this.selectedPoint = null;
                    this.clearHighlights();
                } else if (this.selectedPoint === -1) {
                    // Moving from bar to board
                    const to = pointIndex;

                    // Find valid die value for this entry point
                    let validDieValue = null;
                    for (const dieValue of this.availableMoves) {
                        const entryPoint = this.currentPlayer === 'white' ? 24 - dieValue : dieValue - 1;
                        if (entryPoint === to) {
                            validDieValue = dieValue;
                            break;
                        }
                    }

                    if (validDieValue) {
                        // Check if destination is valid (empty, own pieces, or single opponent piece)
                        const destCheckers = this.board[to];
                        if (destCheckers.length === 0 ||
                            destCheckers[0] === this.currentPlayer ||
                            (destCheckers.length === 1 && destCheckers[0] !== this.currentPlayer)) {

                            this.makeMove(-1, to, validDieValue);
                        } else {
                            this.showMessage('Das Feld ist vom Gegner blockiert!');
                        }
                    } else {
                        this.showMessage('Kein passender W√ºrfel f√ºr dieses Feld!');
                    }

                    this.selectedPoint = null;
                    this.clearHighlights();
                } else {
                    // Try to move from board to board
                    const from = this.selectedPoint;
                    const to = pointIndex;

                    // Calculate die value based on direction (white moves forward, black backward)
                    const direction = this.currentPlayer === 'white' ? 1 : -1;
                    const dieValue = (to - from) * direction;

                    // Check if move is valid
                    if (dieValue > 0 && this.availableMoves.includes(dieValue)) {
                        // Check if destination is blocked
                        const destCheckers = this.board[to];
                        if (destCheckers.length > 1 && destCheckers[0] !== this.currentPlayer) {
                            this.showMessage('Das Feld ist vom Gegner blockiert!');
                        } else {
                            this.makeMove(from, to, dieValue);
                        }
                    } else {
                        this.showMessage('Ung√ºltiger Zug! Pr√ºfe Richtung und verf√ºgbare W√ºrfel.');
                    }

                    this.selectedPoint = null;
                    this.clearHighlights();
                }
            }

            handleBarClick() {
                if (!this.hasRolled || this.gameOver) return;

                if (this.bar[this.currentPlayer] > 0) {
                    this.selectedPoint = -1; // -1 represents bar
                    this.highlightBarEntryPoints();
                }
            }

            handleHomeClick(color) {
                if (!this.hasRolled || this.gameOver) {
                    this.showMessage('Du musst zuerst w√ºrfeln!');
                    return;
                }
                if (color !== this.currentPlayer) {
                    this.showMessage('Nicht dein Zielbereich!');
                    return;
                }

                if (this.selectedPoint !== null && this.selectedPoint !== -1) {
                    // Check if bearing off is allowed
                    const canBearOff = this.checkCanBearOff();
                    if (!canBearOff) {
                        this.showMessage('Du kannst noch nicht abtragen! Alle Steine m√ºssen im Heimfeld sein.');
                        return;
                    }

                    const from = this.selectedPoint;
                    const exactDistance = this.currentPlayer === 'white' ? 24 - from : from + 1;

                    // Find suitable die - exact match first, then higher
                    let selectedDie = null;

                    // Try exact match first
                    for (const die of this.availableMoves) {
                        if (die === exactDistance) {
                            selectedDie = die;
                            break;
                        }
                    }

                    // If no exact match, check if can use higher die
                    if (!selectedDie) {
                        for (const die of this.availableMoves) {
                            if (die > exactDistance) {
                                // Check if no checkers further back (only for higher die usage)
                                let canUseHigherDie = true;
                                const startCheck = this.currentPlayer === 'white' ? from + 1 : 0;
                                const endCheck = this.currentPlayer === 'white' ? 24 : from - 1;

                                for (let i = startCheck; this.currentPlayer === 'white' ? i < endCheck : i <= endCheck; i++) {
                                    if (this.board[i].some(checker => checker === this.currentPlayer)) {
                                        canUseHigherDie = false;
                                        break;
                                    }
                                }

                                if (canUseHigherDie) {
                                    selectedDie = die;
                                    break;
                                }
                            }
                        }
                    }

                    if (selectedDie) {
                        this.makeMove(from, 'home', selectedDie);
                    } else {
                        this.showMessage('Kein passender W√ºrfel f√ºr diesen Abtrag!');
                    }
                } else {
                    this.showMessage('W√§hle zuerst einen Stein aus deinem Heimfeld!');
                }
            }

            checkCanBearOff() {
                const homeStart = this.currentPlayer === 'white' ? 18 : 0;
                const homeEnd = this.currentPlayer === 'white' ? 24 : 6;

                // Check bar
                if (this.bar[this.currentPlayer] > 0) return false;

                // Check all checkers in home
                for (let i = 0; i < 24; i++) {
                    if ((this.currentPlayer === 'white' && i < homeStart) ||
                        (this.currentPlayer === 'black' && i >= homeEnd)) {
                        if (this.board[i].some(checker => checker === this.currentPlayer)) {
                            return false;
                        }
                    }
                }

                return true;
            }

            endTurn() {
                if (!this.hasRolled || this.gameOver) return;

                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.dice = [];
                this.availableMoves = [];
                this.hasRolled = false;
                this.movesMade = 0;
                this.selectedPoint = null;

                this.updateCurrentPlayer();
                this.render();
                this.updateButtons();
                this.updateMoveInfo();
            }

            updateCurrentPlayer() {
                document.getElementById('currentPlayer').textContent =
                    `${this.currentPlayer === 'white' ? 'Wei√ü' : 'Schwarz'} ist am Zug`;

                // Automatisches W√ºrfeln wenn der Spieler noch nicht gew√ºrfelt hat
                if (!this.hasRolled) {
                    // L√§ngeres Delay beim ersten Zug des Spiels f√ºr korrekte Initialisierung
                    const isGameStart = this.movesMade === 0;
                    const delay = isGameStart ? 1000 : 500;

                    setTimeout(() => {
                        // Doppelte √úberpr√ºfung vor dem W√ºrfeln
                        if (!this.hasRolled && !this.gameOver) {
                            this.rollDice();
                        }
                    }, delay);
                }
            }

            updateMoveInfo() {
                const moveInfo = document.getElementById('moveInfo');
                if (this.availableMoves.length > 0) {
                    moveInfo.textContent = `Verf√ºgbare Z√ºge: ${this.availableMoves.join(', ')}`;
                } else {
                    moveInfo.textContent = '';
                }
            }

            updateButtons() {
                // W√ºrfel-Button wurde entfernt - automatisches W√ºrfeln implementiert
            }

            render() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';

                // Obere Reihe (Points 12-23)
                for (let i = 12; i < 18; i++) {
                    this.renderPoint(i, 'top', boardElement);
                }

                // Bar (obere H√§lfte)
                const barTop = document.createElement('div');
                barTop.className = 'bar';
                barTop.style.gridRow = '1';
                boardElement.appendChild(barTop);

                // Rechte H√§lfte (18-23)
                for (let i = 18; i < 24; i++) {
                    this.renderPoint(i, 'top', boardElement);
                }

                // Untere Reihe (Points 11-0)
                for (let i = 11; i >= 6; i--) {
                    this.renderPoint(i, 'bottom', boardElement);
                }

                // Bar (untere H√§lfte)
                const barBottom = document.createElement('div');
                barBottom.className = 'bar';
                barBottom.style.gridRow = '2';

                // Bar-Inhalte hinzuf√ºgen
                if (this.bar.white > 0) {
                    for (let i = 0; i < this.bar.white; i++) {
                        const checker = this.createChecker('white');
                        barBottom.appendChild(checker);
                    }
                }
                if (this.bar.black > 0) {
                    for (let i = 0; i < this.bar.black; i++) {
                        const checker = this.createChecker('black');
                        barTop.appendChild(checker);
                    }
                }

                // Add click handlers to bar
                barTop.addEventListener('click', () => {
                    if (this.bar[this.currentPlayer] > 0 && this.currentPlayer === 'black') {
                        this.handleBarClick();
                    }
                });

                barBottom.addEventListener('click', () => {
                    if (this.bar[this.currentPlayer] > 0 && this.currentPlayer === 'white') {
                        this.handleBarClick();
                    }
                });

                boardElement.appendChild(barBottom);

                // Rechte H√§lfte (5-0)
                for (let i = 5; i >= 0; i--) {
                    this.renderPoint(i, 'bottom', boardElement);
                }

                // Home-Bereiche rendern
                this.renderHome();
            }

            renderPoint(index, position, container) {
                const point = document.createElement('div');
                point.className = `point ${position}`;
                point.dataset.point = index;

                if (this.selectedPoint === index) {
                    point.classList.add('selected');
                }

                const checkers = this.board[index];
                const maxVisible = 5;

                checkers.forEach((color, i) => {
                    if (i < maxVisible) {
                        const checker = this.createChecker(color);
                        point.appendChild(checker);
                    }
                });

                if (checkers.length > maxVisible) {
                    const counter = document.createElement('div');
                    counter.className = 'counter';
                    counter.textContent = checkers.length;
                    point.appendChild(counter);
                }

                container.appendChild(point);
            }

            renderHome() {
                const homeWhite = document.getElementById('homeWhite');
                const homeBlack = document.getElementById('homeBlack');

                if (!homeWhite || !homeBlack) return;

                // Update counters
                const whiteCountEl = homeWhite.querySelector('.home-count');
                const blackCountEl = homeBlack.querySelector('.home-count');

                if (whiteCountEl) whiteCountEl.textContent = this.home.white;
                if (blackCountEl) blackCountEl.textContent = this.home.black;

                // Visual representation of checkers in home
                const whiteCheckersContainer = homeWhite.querySelector('.home-checkers') || document.createElement('div');
                const blackCheckersContainer = homeBlack.querySelector('.home-checkers') || document.createElement('div');

                if (!homeWhite.querySelector('.home-checkers')) {
                    whiteCheckersContainer.className = 'home-checkers';
                    homeWhite.appendChild(whiteCheckersContainer);
                }
                if (!homeBlack.querySelector('.home-checkers')) {
                    blackCheckersContainer.className = 'home-checkers';
                    homeBlack.appendChild(blackCheckersContainer);
                }

                whiteCheckersContainer.innerHTML = '';
                blackCheckersContainer.innerHTML = '';

                const maxVisible = 5;

                // Show white checkers in home
                for (let i = 0; i < Math.min(this.home.white, maxVisible); i++) {
                    const checker = this.createChecker('white');
                    checker.style.width = '18px';
                    checker.style.height = '18px';
                    checker.style.margin = '1px';
                    whiteCheckersContainer.appendChild(checker);
                }

                // Show black checkers in home
                for (let i = 0; i < Math.min(this.home.black, maxVisible); i++) {
                    const checker = this.createChecker('black');
                    checker.style.width = '18px';
                    checker.style.height = '18px';
                    checker.style.margin = '1px';
                    blackCheckersContainer.appendChild(checker);
                }

                // Highlight valid moves for bearing off
                if (this.selectedPoint !== null && this.canBearOff(this.currentPlayer)) {
                    const validMoves = this.getValidMoves(this.selectedPoint);
                    if (validMoves.includes('home')) {
                        if (this.currentPlayer === 'white') {
                            homeWhite.classList.add('valid-move');
                        } else {
                            homeBlack.classList.add('valid-move');
                        }
                    }
                }

                // Add event listeners for bearing off
                homeWhite.onclick = () => this.handleHomeClick('white');
                homeBlack.onclick = () => this.handleHomeClick('black');
            }

            createChecker(color) {
                const checker = document.createElement('div');
                checker.className = `checker ${color}`;
                if (color === this.currentPlayer && this.hasRolled) {
                    checker.classList.add('draggable');
                }
                return checker;
            }

            showMessage(text) {
                const existing = document.querySelector('.message');
                if (existing) existing.remove();

                const message = document.createElement('div');
                message.className = 'message';
                message.textContent = text;
                document.body.appendChild(message);

                setTimeout(() => message.remove(), 2500);
            }
        }

        // Multiplayer Game Class
        class MultiplayerBackgammon {
            constructor(app) {
                this.app = app;
                this.socket = null;
                this.gameState = {
                    board: Array(24).fill(null).map(() => []),
                    availableMoves: [],
                    hasRolled: false,
                    home: { white: 0, black: 0 },
                    bar: { white: 0, black: 0 },
                    currentPlayer: null,
                    dice: []
                };
                this.playerColor = null;
                this.gameId = null;
                this.selectedPoint = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;

                this.initializeSocket();
                this.setupEvents();
            }

            initializeSocket() {
                console.log('üîå Initializing socket connection...');

                const socketUrl = window.location.origin;
                this.socket = io(socketUrl, {
                    transports: ['websocket', 'polling'],
                    forceNew: true,
                    reconnection: true,
                    timeout: 20000,
                    reconnectionDelay: 1000,
                    reconnectionAttempts: this.maxReconnectAttempts
                });

                this.setupSocketEvents();
            }

            setupSocketEvents() {
                this.socket.on('connect', () => {
                    console.log('‚úÖ Connected to server:', this.socket.id);
                    this.updateConnectionStatus(true);
                    this.reconnectAttempts = 0;
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('‚ùå Disconnected from server:', reason);
                    this.updateConnectionStatus(false);
                    this.showMessage('Verbindung zum Server verloren');

                    if (reason === 'io server disconnect') {
                        this.socket.connect();
                    }
                });

                this.socket.on('connect_error', (error) => {
                    console.error('üí• Connection error:', error);
                    this.updateConnectionStatus(false);
                    this.reconnectAttempts++;

                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        this.showMessage('Kann keine Verbindung zum Server herstellen. Bitte Seite neu laden.');
                    } else {
                        this.showMessage(`Verbindungsfehler. Wiederholung ${this.reconnectAttempts}/${this.maxReconnectAttempts}...`);
                    }
                });

                this.socket.on('reconnect', (attemptNumber) => {
                    console.log(`üîÑ Reconnected after ${attemptNumber} attempts`);
                    this.updateConnectionStatus(true);
                    this.showMessage('Verbindung wiederhergestellt!');
                });

                this.socket.on('queue-joined', (data) => {
                    console.log('üéØ Joined queue:', data);
                    this.updateLobbyStatus(`In der Warteschlange... Position: ${data.position}`);
                });

                this.socket.on('waiting-for-opponent', () => {
                    console.log('‚è≥ Waiting for opponent...');
                    this.updateLobbyStatus('Warte auf Gegner...');
                });

                this.socket.on('game-started', (data) => {
                    console.log('üéÆ Game started:', data);
                    this.gameId = data.gameId;
                    this.playerColor = data.playerColor;

                    // Merge with default gameState structure
                    this.gameState = {
                        ...this.gameState,
                        ...data.gameState,
                        board: data.gameState?.board || Array(24).fill(null).map(() => []),
                        availableMoves: data.gameState?.availableMoves || [],
                        home: data.gameState?.home || { white: 0, black: 0 },
                        bar: data.gameState?.bar || { white: 0, black: 0 }
                    };

                    this.app.showMultiplayerGame();
                    this.updatePlayerNames(data);
                    this.render();

                    this.showMessage(`Spiel gestartet! Du spielst als ${this.playerColor === 'white' ? 'Wei√ü' : 'Schwarz'}`);
                });

                this.socket.on('game-updated', (gameState) => {
                    console.log('üìä Game state updated:', gameState);
                    console.log('üìä Available moves in update:', gameState?.availableMoves);

                    // Merge with existing gameState structure
                    this.gameState = {
                        ...this.gameState,
                        ...gameState,
                        board: gameState?.board || Array(24).fill(null).map(() => []),
                        availableMoves: gameState?.availableMoves || [],
                        home: gameState?.home || { white: 0, black: 0 },
                        bar: gameState?.bar || { white: 0, black: 0 }
                    };

                    console.log('üìä Final gameState after merge:', this.gameState);
                    this.render();
                });

                this.socket.on('dice-rolled', (data) => {
                    console.log('üé≤ Dice rolled:', data);
                    const die1 = document.getElementById('die1');
                    const die2 = document.getElementById('die2');

                    die1.classList.add('rolling');
                    die2.classList.add('rolling');

                    setTimeout(() => {
                        die1.textContent = data.dice[0];
                        die2.textContent = data.dice[1];
                        die1.classList.remove('rolling');
                        die2.classList.remove('rolling');

                        // Merge dice roll data with existing gameState
                        if (this.gameState) {
                            this.gameState = {
                                ...this.gameState,
                                dice: data.dice,
                                availableMoves: data.movesLeft || [],
                                hasRolled: true
                            };
                        } else {
                            // Initialize gameState if it doesn't exist
                            this.gameState = {
                                board: Array(24).fill(null).map(() => []),
                                dice: data.dice,
                                availableMoves: data.movesLeft || [],
                                hasRolled: true,
                                home: { white: 0, black: 0 },
                                bar: { white: 0, black: 0 }
                            };
                        }

                        this.updateMoveInfo();
                        this.updateButtons();

                        if (data.dice[0] === data.dice[1]) {
                            this.showMessage(`Pasch! ${data.dice[0]}er Pasch gew√ºrfelt!`);
                        }

                        console.log('Updated gameState after dice roll:', this.gameState);
                    }, 500);
                });

                this.socket.on('turn-changed', (data) => {
                    console.log('üîÑ Turn changed:', data);
                    this.gameState = data.gameState;
                    this.render();

                    const currentPlayerName = data.currentPlayer === 'white' ? 'Wei√ü' : 'Schwarz';
                    const isMyTurn = data.currentPlayer === this.playerColor;

                    if (isMyTurn) {
                        this.showMessage('Du bist am Zug!');
                    } else {
                        this.showMessage(`${currentPlayerName} ist am Zug`);
                    }
                });

                this.socket.on('move-error', (data) => {
                    console.log('‚ùå Move error:', data.message);
                    this.showMessage(data.message);
                });

                this.socket.on('dice-error', (data) => {
                    console.log('‚ùå Dice error:', data.message);
                    this.showMessage(data.message);
                });

                this.socket.on('game-finished', (data) => {
                    console.log('üèÜ Game finished:', data);
                    const winner = data.winner === 'white' ? 'Wei√ü' : 'Schwarz';
                    const isWinner = data.winner === this.playerColor;

                    if (isWinner) {
                        this.showMessage(`üéâ Du hast gewonnen!`);
                    } else {
                        this.showMessage(`${winner} hat gewonnen!`);
                    }

                    setTimeout(() => this.app.showMenu(), 5000);
                });

                this.socket.on('player-disconnected', (data) => {
                    console.log('üëã Player disconnected:', data.message);
                    this.showMessage(data.message);
                    setTimeout(() => this.app.showMenu(), 3000);
                });
            }

            setupEvents() {
                // Lobby events
                document.getElementById('findOpponentBtn').addEventListener('click', () => {
                    this.startMatchmaking();
                });

                document.getElementById('cancelSearchBtn').addEventListener('click', () => {
                    this.cancelSearch();
                });

                // Game events
                // Board click events
                document.getElementById('board').addEventListener('click', (e) => {
                    this.handleBoardClick(e);
                });

                // Bar click events
                document.addEventListener('click', (e) => {
                    const barEl = e.target.closest('.bar');
                    if (barEl && this.gameState) {
                        this.handleBarClick();
                    }
                });

                // Home click events
                document.getElementById('homeWhite').addEventListener('click', () => {
                    if (this.playerColor === 'white') {
                        this.handleHomeClick();
                    }
                });

                document.getElementById('homeBlack').addEventListener('click', () => {
                    if (this.playerColor === 'black') {
                        this.handleHomeClick();
                    }
                });

                // Home click events for multiplayer
                document.getElementById('homeWhite').addEventListener('click', () => {
                    if (this.playerColor === 'white') {
                        this.handleHomeClick();
                    }
                });

                document.getElementById('homeBlack').addEventListener('click', () => {
                    if (this.playerColor === 'black') {
                        this.handleHomeClick();
                    }
                });

                // Enter key in name input
                document.getElementById('playerName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.startMatchmaking();
                    }
                });
            }

            startMatchmaking() {
                const playerName = document.getElementById('playerName').value.trim();
                if (!playerName) {
                    this.showMessage('Bitte gib deinen Namen ein!');
                    document.getElementById('playerName').focus();
                    return;
                }

                if (!this.socket || !this.socket.connected) {
                    this.showMessage('Keine Verbindung zum Server. Versuche zu verbinden...');
                    this.initializeSocket();

                    setTimeout(() => {
                        if (this.socket && this.socket.connected) {
                            this.startMatchmaking();
                        }
                    }, 2000);
                    return;
                }

                console.log('üéØ Starting matchmaking with name:', playerName);
                this.socket.emit('join-queue', { name: playerName });

                document.getElementById('findOpponentBtn').style.display = 'none';
                document.getElementById('cancelSearchBtn').style.display = 'block';
                document.getElementById('playerName').disabled = true;

                this.updateLobbyStatus('üîç Suche nach Gegner...');
            }

            cancelSearch() {
                if (this.socket && this.socket.connected) {
                    this.socket.emit('leave-queue');
                }

                document.getElementById('findOpponentBtn').style.display = 'block';
                document.getElementById('cancelSearchBtn').style.display = 'none';
                document.getElementById('playerName').disabled = false;

                this.updateLobbyStatus('');
                console.log('üö´ Search cancelled');
            }

            updateLobbyStatus(status) {
                const statusEl = document.getElementById('lobbyStatus');
                statusEl.innerHTML = status ? `<div class="waiting-animation">${status}</div>` : '';
            }

            updateConnectionStatus(connected) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = connected ? 'Verbunden' : 'Getrennt';
                statusEl.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
            }

            updatePlayerNames(data) {
                document.getElementById('whitePlayerName').textContent =
                    this.playerColor === 'white' ? 'Du (Wei√ü)' : data.opponent + ' (Wei√ü)';
                document.getElementById('blackPlayerName').textContent =
                    this.playerColor === 'black' ? 'Du (Schwarz)' : data.opponent + ' (Schwarz)';
            }

            canRoll() {
                return this.gameState &&
                    this.gameState.currentPlayer === this.playerColor &&
                    !this.gameState.hasRolled;
            }

            handleBoardClick(e) {
                if (!this.gameState || this.gameState.currentPlayer !== this.playerColor) {
                    return;
                }

                const pointEl = e.target.closest('.point');
                if (pointEl) {
                    const pointIndex = parseInt(pointEl.dataset.point);
                    this.handlePointClick(pointIndex);
                }
            }

            handlePointClick(pointIndex) {
                console.log('üéØ Point click debug:', {
                    gameState: !!this.gameState,
                    currentPlayer: this.gameState?.currentPlayer,
                    playerColor: this.playerColor,
                    hasRolled: this.gameState?.hasRolled,
                    availableMoves: this.gameState?.availableMoves,
                    movesLength: this.gameState?.availableMoves?.length
                });

                // Check if it's the player's turn
                if (!this.gameState || this.gameState.currentPlayer !== this.playerColor) {
                    this.showMessage('Du bist nicht am Zug!');
                    return;
                }

                // Check if dice have been rolled
                if (!this.gameState.hasRolled) {
                    this.showMessage('Du musst zuerst w√ºrfeln!');
                    return;
                }

                // Check if moves are available ONLY if hasRolled is true
                if (this.gameState.hasRolled && (!this.gameState.availableMoves || this.gameState.availableMoves.length === 0)) {
                    console.log('üö´ No moves available after rolling. GameState:', this.gameState);
                    this.showMessage('Keine Z√ºge mehr verf√ºgbar! Beende deinen Zug.');
                    return;
                }

                // Check if player has checkers on bar - BUT only if not already moving from bar
                if (this.gameState.bar[this.playerColor] > 0 && this.selectedPoint !== -1) {
                    this.showMessage('Du musst zuerst Steine von der Bar einw√ºrfeln!');
                    return;
                }

                if (this.selectedPoint === null) {
                    // Select a checker - only if it belongs to the player
                    if (this.gameState.board[pointIndex].length > 0 &&
                        this.gameState.board[pointIndex][this.gameState.board[pointIndex].length - 1] === this.playerColor) {
                        this.selectedPoint = pointIndex;
                        this.highlightValidMoves(pointIndex);
                    } else {
                        this.showMessage('Du kannst nur deine eigenen Steine bewegen!');
                    }
                } else if (this.selectedPoint === pointIndex) {
                    // Deselect
                    this.selectedPoint = null;
                    this.clearHighlights();
                } else if (this.selectedPoint === -1) {
                    // Moving from bar to board
                    const to = pointIndex;

                    // Find valid die value for this entry point
                    let validDieValue = null;
                    for (const dieValue of this.gameState.availableMoves) {
                        const entryPoint = this.playerColor === 'white' ? dieValue - 1 : 24 - dieValue;
                        console.log(`Checking die ${dieValue}, calculated entry point: ${entryPoint}, target point: ${to}`);
                        if (entryPoint === to) {
                            validDieValue = dieValue;
                            break;
                        }
                    }

                    if (validDieValue) {
                        // Check if destination is valid (empty, own pieces, or single opponent piece)
                        const destCheckers = this.gameState.board[to];
                        if (destCheckers.length === 0 ||
                            destCheckers[0] === this.playerColor ||
                            (destCheckers.length === 1 && destCheckers[0] !== this.playerColor)) {

                            this.socket.emit('make-move', {
                                from: -1, // -1 = bar
                                to: to,
                                dieValue: validDieValue
                            });
                        } else {
                            this.showMessage('Das Feld ist vom Gegner blockiert!');
                        }
                    } else {
                        this.showMessage('Kein passender W√ºrfel f√ºr dieses Feld!');
                    }

                    this.selectedPoint = null;
                    this.clearHighlights();
                } else {
                    // Try to move from board to board
                    const from = this.selectedPoint;
                    const to = pointIndex;

                    // Calculate die value based on direction (white moves forward, black backward)
                    const direction = this.playerColor === 'white' ? 1 : -1;
                    const dieValue = (to - from) * direction;

                    // Check if move is valid
                    if (dieValue > 0 && this.gameState.availableMoves && this.gameState.availableMoves.includes(dieValue)) {
                        // Check if destination is blocked
                        const destCheckers = this.gameState.board[to];
                        if (destCheckers.length > 1 && destCheckers[0] !== this.playerColor) {
                            this.showMessage('Das Feld ist vom Gegner blockiert!');
                        } else {
                            this.socket.emit('make-move', {
                                from: from,
                                to: to,
                                dieValue: dieValue
                            });
                        }
                    } else {
                        this.showMessage('Ung√ºltiger Zug! Pr√ºfe Richtung und verf√ºgbare W√ºrfel.');
                    }

                    this.selectedPoint = null;
                    this.clearHighlights();
                }
            }

            handleBarClick() {
                if (!this.gameState || this.gameState.currentPlayer !== this.playerColor) {
                    return;
                }

                if (!this.gameState.hasRolled || !this.gameState.availableMoves || this.gameState.availableMoves.length === 0) {
                    this.showMessage('Du musst zuerst w√ºrfeln!');
                    return;
                }

                if (this.gameState.bar[this.playerColor] > 0) {
                    this.selectedPoint = -1; // -1 represents bar
                    this.highlightBarEntryPoints();
                } else {
                    this.showMessage('Du hast keine Steine auf der Bar!');
                }
            }

            handleHomeClick() {
                if (!this.gameState || this.gameState.currentPlayer !== this.playerColor) {
                    return;
                }

                if (!this.gameState.hasRolled || !this.gameState.availableMoves || this.gameState.availableMoves.length === 0) {
                    this.showMessage('Du musst zuerst w√ºrfeln!');
                    return;
                }

                if (this.selectedPoint !== null && this.selectedPoint !== -1) {
                    // Check if bearing off is allowed
                    const canBearOff = this.checkCanBearOff();
                    if (canBearOff) {
                        const from = this.selectedPoint;
                        const exactDistance = this.playerColor === 'white' ? 24 - from : from + 1;

                        // Find suitable die (exact match or higher if allowed)
                        let selectedDie = null;

                        // First try to find exact match
                        if (this.gameState.availableMoves.includes(exactDistance)) {
                            selectedDie = exactDistance;
                        } else {
                            // Find higher die that can be used
                            for (const die of this.gameState.availableMoves.sort((a, b) => a - b)) {
                                if (die > exactDistance) {
                                    // Check if no checkers further back
                                    let canUseHigherDie = true;
                                    const startCheck = this.playerColor === 'white' ? from + 1 : 0;
                                    const endCheck = this.playerColor === 'white' ? 24 : from - 1;

                                    for (let i = startCheck; this.playerColor === 'white' ? i < endCheck : i <= endCheck; i++) {
                                        if (this.gameState.board[i].some(checker => checker === this.playerColor)) {
                                            canUseHigherDie = false;
                                            break;
                                        }
                                    }

                                    if (canUseHigherDie) {
                                        selectedDie = die;
                                        break;
                                    }
                                }
                            }
                        }

                        if (selectedDie) {
                            this.socket.emit('make-move', {
                                from: from,
                                to: 25, // 25 = bearing off
                                dieValue: selectedDie
                            });

                            this.selectedPoint = null;
                            this.clearHighlights();
                        } else {
                            this.showMessage('Kein passender W√ºrfel f√ºr das Abr√§umen verf√ºgbar!');
                        }
                    } else {
                        this.showMessage('Abr√§umen nur m√∂glich wenn alle Steine im Home-Bereich sind!');
                    }
                } else if (this.selectedPoint === -1) {
                    // Selected from bar, try to enter
                    for (const dieValue of this.gameState.availableMoves) {
                        const entryPoint = this.playerColor === 'white' ? dieValue - 1 : 24 - dieValue;

                        if (entryPoint >= 0 && entryPoint < 24) {
                            const destCheckers = this.gameState.board[entryPoint];
                            if (destCheckers.length <= 1 || destCheckers[0] === this.playerColor) {
                                this.socket.emit('make-move', {
                                    from: -1, // -1 = bar
                                    to: entryPoint,
                                    dieValue: dieValue
                                });

                                this.selectedPoint = null;
                                this.clearHighlights();
                                return;
                            }
                        }
                    }
                    this.showMessage('Kein g√ºltiger Einw√ºrfelzug m√∂glich!');
                }
            }

            checkCanBearOff() {
                const homeStart = this.playerColor === 'white' ? 18 : 0;
                const homeEnd = this.playerColor === 'white' ? 24 : 6;

                // Check bar
                if (this.gameState.bar[this.playerColor] > 0) return false;

                // Check all checkers in home
                for (let i = 0; i < 24; i++) {
                    if ((this.playerColor === 'white' && i < homeStart) ||
                        (this.playerColor === 'black' && i >= homeEnd)) {
                        if (this.gameState.board[i].some(checker => checker === this.playerColor)) {
                            return false;
                        }
                    }
                }

                return true;
            }

            highlightBarEntryPoints() {
                this.clearHighlights();

                if (!this.gameState || !this.gameState.availableMoves) {
                    return;
                }

                for (const move of this.gameState.availableMoves) {
                    const targetPoint = this.playerColor === 'white' ? move - 1 : 24 - move;

                    if (targetPoint >= 0 && targetPoint < 24 && this.isValidMove(-1, targetPoint)) {
                        const targetEl = document.querySelector(`[data-point="${targetPoint}"]`);
                        if (targetEl) targetEl.classList.add('valid-move');
                    }
                }
            }

            highlightValidMoves(fromPoint) {
                this.clearHighlights();

                const pointEl = document.querySelector(`[data-point="${fromPoint}"]`);
                if (pointEl) {
                    pointEl.classList.add('selected');
                }

                if (!this.gameState || !this.gameState.availableMoves) {
                    return;
                }

                this.gameState.availableMoves.forEach(dieValue => {
                    let toPoint;
                    if (this.playerColor === 'white') {
                        toPoint = fromPoint + dieValue;
                    } else {
                        toPoint = fromPoint - dieValue;
                    }

                    // Regular moves
                    if (toPoint >= 0 && toPoint < 24) {
                        const toPointEl = document.querySelector(`[data-point="${toPoint}"]`);
                        if (toPointEl && this.isValidMove(fromPoint, toPoint)) {
                            toPointEl.classList.add('valid-move');
                        }
                    }

                    // Bearing off
                    if (this.checkCanBearOff()) {
                        const exactDistance = this.playerColor === 'white' ? 24 - fromPoint : fromPoint + 1;

                        // Exact die match
                        if (dieValue === exactDistance) {
                            const homeEl = document.getElementById(this.playerColor === 'white' ? 'homeWhite' : 'homeBlack');
                            if (homeEl) homeEl.classList.add('valid-move');
                        }
                        // Higher die, if no checkers further back
                        else if (dieValue > exactDistance) {
                            let canUseHigherDie = true;
                            const startCheck = this.playerColor === 'white' ? fromPoint + 1 : 0;
                            const endCheck = this.playerColor === 'white' ? 24 : fromPoint - 1;

                            for (let i = startCheck; this.playerColor === 'white' ? i < endCheck : i <= endCheck; i++) {
                                if (this.gameState.board[i].some(checker => checker === this.playerColor)) {
                                    canUseHigherDie = false;
                                    break;
                                }
                            }

                            if (canUseHigherDie) {
                                const homeEl = document.getElementById(this.playerColor === 'white' ? 'homeWhite' : 'homeBlack');
                                if (homeEl) homeEl.classList.add('valid-move');
                            }
                        }
                    }
                });
            }

            clearHighlights() {
                document.querySelectorAll('.point, .home').forEach(point => {
                    point.classList.remove('selected', 'valid-move');
                });
            }

            isValidMove(from, to) {
                const destinationCheckers = this.gameState.board[to];
                if (destinationCheckers.length === 0) return true;
                if (destinationCheckers[0] === this.playerColor) return true;
                if (destinationCheckers.length === 1) return true; // Can hit single opponent checker
                return false;
            }

            updateMoveInfo() {
                const moveInfoEl = document.getElementById('moveInfo');
                if (!this.gameState || !this.gameState.availableMoves) return;

                const moves = this.gameState.availableMoves;
                if (moves.length > 0) {
                    moveInfoEl.textContent = `Verf√ºgbare Z√ºge: ${moves.join(', ')}`;
                } else if (this.gameState.hasRolled) {
                    moveInfoEl.textContent = 'Alle Z√ºge verwendet';
                } else {
                    moveInfoEl.textContent = '';
                }
            }

            updateButtons() {
                // W√ºrfel-Button wurde entfernt - automatisches W√ºrfeln implementiert
            }

            render() {
                if (!this.gameState) return;

                this.renderBoard();
                this.renderHome();
                this.updateCurrentPlayer();
                this.updateMoveInfo();
                this.updateButtons();
            }

            renderBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';

                // Obere Reihe (Points 12-23)
                for (let i = 12; i < 18; i++) {
                    this.renderPoint(i, 'top', boardEl);
                }

                // Bar (obere H√§lfte)
                const barTop = document.createElement('div');
                barTop.className = 'bar';
                barTop.style.gridRow = '1';

                // Add click handler to bar top (for black pieces)
                barTop.addEventListener('click', () => {
                    if (this.gameState.bar[this.playerColor] > 0 && this.playerColor === 'black') {
                        this.handleBarClick();
                    }
                });

                boardEl.appendChild(barTop);

                // Rechte H√§lfte (18-23)
                for (let i = 18; i < 24; i++) {
                    this.renderPoint(i, 'top', boardEl);
                }

                // Untere Reihe (Points 11-0)
                for (let i = 11; i >= 6; i--) {
                    this.renderPoint(i, 'bottom', boardEl);
                }

                // Bar (untere H√§lfte)
                const barBottom = document.createElement('div');
                barBottom.className = 'bar';
                barBottom.style.gridRow = '2';

                // Bar-Inhalte hinzuf√ºgen
                if (this.gameState.bar.white > 0) {
                    for (let i = 0; i < this.gameState.bar.white; i++) {
                        const checker = this.createChecker('white');
                        barBottom.appendChild(checker);
                    }
                }
                if (this.gameState.bar.black > 0) {
                    for (let i = 0; i < this.gameState.bar.black; i++) {
                        const checker = this.createChecker('black');
                        barTop.appendChild(checker);
                    }
                }

                // Add click handler to bar bottom (for white pieces)
                barBottom.addEventListener('click', () => {
                    if (this.gameState.bar[this.playerColor] > 0 && this.playerColor === 'white') {
                        this.handleBarClick();
                    }
                });

                boardEl.appendChild(barBottom);

                // Rechte H√§lfte (5-0)
                for (let i = 5; i >= 0; i--) {
                    this.renderPoint(i, 'bottom', boardEl);
                }
            }

            renderPoint(index, position, container) {
                const point = document.createElement('div');
                point.className = `point ${position}`;
                point.dataset.point = index;

                if (this.selectedPoint === index) {
                    point.classList.add('selected');
                }

                // Safety check for board existence
                if (!this.gameState.board || !this.gameState.board[index]) {
                    container.appendChild(point);
                    return;
                }

                const checkers = this.gameState.board[index];
                const maxVisible = 5;

                checkers.forEach((color, i) => {
                    if (i < maxVisible) {
                        const checker = this.createChecker(color);
                        point.appendChild(checker);
                    }
                });

                if (checkers.length > maxVisible) {
                    const counter = document.createElement('div');
                    counter.className = 'counter';
                    counter.textContent = checkers.length;
                    point.appendChild(counter);
                }

                container.appendChild(point);
            }

            renderHome() {
                const whiteHomeEl = document.getElementById('homeWhite');
                const blackHomeEl = document.getElementById('homeBlack');

                if (!whiteHomeEl || !blackHomeEl) return;

                // Clear and rebuild home areas
                whiteHomeEl.innerHTML = '<div class="home-label">Ziel Wei√ü</div><div class="home-count">0</div>';
                blackHomeEl.innerHTML = '<div class="home-label">Ziel Schwarz</div><div class="home-count">0</div>';

                // Safety check for home property
                if (!this.gameState.home) {
                    return;
                }

                // Update counters
                const whiteCountEl = whiteHomeEl.querySelector('.home-count');
                const blackCountEl = blackHomeEl.querySelector('.home-count');

                if (whiteCountEl) whiteCountEl.textContent = this.gameState.home.white;
                if (blackCountEl) blackCountEl.textContent = this.gameState.home.black;

                // Visual representation of checkers in home
                const whiteCheckersContainer = document.createElement('div');
                const blackCheckersContainer = document.createElement('div');
                whiteCheckersContainer.className = 'home-checkers';
                blackCheckersContainer.className = 'home-checkers';

                whiteHomeEl.appendChild(whiteCheckersContainer);
                blackHomeEl.appendChild(blackCheckersContainer);

                const maxVisible = 5;

                // Show white checkers in home
                for (let i = 0; i < Math.min(this.gameState.home.white, maxVisible); i++) {
                    const checker = this.createChecker('white');
                    checker.style.width = '18px';
                    checker.style.height = '18px';
                    checker.style.margin = '1px';
                    whiteCheckersContainer.appendChild(checker);
                }

                // Show black checkers in home
                for (let i = 0; i < Math.min(this.gameState.home.black, maxVisible); i++) {
                    const checker = this.createChecker('black');
                    checker.style.width = '18px';
                    checker.style.height = '18px';
                    checker.style.margin = '1px';
                    blackCheckersContainer.appendChild(checker);
                }
            }

            createChecker(color) {
                const checker = document.createElement('div');
                checker.className = `checker ${color}`;
                if (color === this.playerColor && this.gameState.currentPlayer === this.playerColor) {
                    checker.classList.add('draggable');
                }
                return checker;
            }

            updateCurrentPlayer() {
                const currentPlayerEl = document.getElementById('currentPlayer');
                if (this.gameState.currentPlayer === this.playerColor) {
                    currentPlayerEl.textContent = 'Du bist am Zug';
                    currentPlayerEl.style.color = '#4CAF50';

                    // Automatisches W√ºrfeln wenn der Spieler am Zug ist und noch nicht gew√ºrfelt hat
                    if (!this.gameState.hasRolled && this.canRoll()) {
                        // L√§ngeres Delay beim ersten Zug f√ºr korrekte Spielinitialisierung
                        const isGameStart = !this.gameState.dice || this.gameState.dice.length === 0;
                        const delay = isGameStart ? 1500 : 500;

                        setTimeout(() => {
                            // Mehrfache √úberpr√ºfung vor dem W√ºrfeln
                            if (!this.gameState.hasRolled &&
                                this.gameState.currentPlayer === this.playerColor &&
                                this.canRoll()) {
                                this.socket.emit('roll-dice');
                            }
                        }, delay);
                    }
                } else {
                    currentPlayerEl.textContent = 'Gegner ist am Zug';
                    currentPlayerEl.style.color = '#FF9800';
                }
            }

            showMessage(text) {
                const existingMessage = document.querySelector('.message');
                if (existingMessage) {
                    existingMessage.remove();
                }

                const message = document.createElement('div');
                message.className = 'message';
                message.textContent = text;
                document.body.appendChild(message);

                setTimeout(() => {
                    message.remove();
                }, 3000);
            }
        }

        // Start the app
        const app = new BackgammonApp();

        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevent scrolling
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>

</html>