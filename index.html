<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backgammon Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background-image: url('https://images.pexels.com/photos/326311/pexels-photo-326311.jpeg');
            background-size: cover;
            background-position: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            max-width: 500px;
        }

        .game-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 10px 20px;
            width: 100%;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .current-player {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 10px 0;
        }

        .die {
            width: 45px;
            height: 45px;
            background: #fff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .die.rolling {
            animation: roll 0.5s ease-in-out;
        }

        @keyframes roll {
            0% {
                transform: rotate(0deg) scale(1);
            }

            50% {
                transform: rotate(360deg) scale(1.2);
            }

            100% {
                transform: rotate(720deg) scale(1);
            }
        }

        .board-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            position: relative;
        }

        .board-container {
            position: relative;
            width: 95vw;
            max-width: 450px;
            aspect-ratio: 1 / 1.3;
            background: #8b6914;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 6px solid #5a420d;
        }

        .board {
            position: absolute;
            inset: 5px;
            display: grid;
            grid-template-columns: repeat(6, 1fr) 30px repeat(6, 1fr);
            grid-template-rows: 1fr 1fr;
            gap: 2px;
        }

        .bar {
            grid-column: 7;
            background: #5a420d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 5px 0;
        }

        .point {
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
        }

        .point.top {
            align-items: flex-start;
            flex-direction: column-reverse;
        }

        .point.bottom {
            align-items: flex-end;
            flex-direction: column;
        }

        .point::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            left: 50%;
            transform: translateX(-50%);
        }

        .point.top::before {
            top: 0;
            border-width: 0 20px 80px 20px;
        }

        .point.bottom::before {
            bottom: 0;
            border-width: 80px 20px 0 20px;
        }

        .point:nth-child(odd)::before {
            border-color: #d2691e transparent;
        }

        .point:nth-child(even)::before {
            border-color: #8b4513 transparent;
        }

        .point.top:nth-child(odd)::before {
            border-color: transparent transparent #d2691e transparent;
        }

        .point.top:nth-child(even)::before {
            border-color: transparent transparent #8b4513 transparent;
        }

        .point.valid-move {
            background: rgba(0, 255, 0, 0.3);
        }

        .point.selected {
            background: rgba(255, 255, 0, 0.3);
        }

        .checker {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            position: relative;
            margin: 1px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1;
            flex-shrink: 0;
        }

        .checker.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .checker.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            border: 1px solid #222;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .checker.draggable {
            cursor: grab;
        }

        .checker.draggable:active {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 100;
        }

        .home {
            position: absolute;
            width: 35px;
            height: 45%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 3px;
            gap: 1px;
        }

        .home.white {
            right: -25px;
            bottom: 5%;
        }

        .home.black {
            right: -25px;
            top: 5%;
        }

        .controls {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex: 1;
            min-width: 100px;
            max-width: 150px;
        }

        button:active:not(:disabled) {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2em;
            z-index: 1000;
            animation: popIn 0.3s ease-out;
            text-align: center;
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .counter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        @media (max-height: 700px) {
            .board-container {
                aspect-ratio: 1 / 1.1;
            }

            .point::before {
                border-width: 0 15px 60px 15px;
            }

            .point.top::before {
                border-width: 60px 15px 0 15px;
            }
        }

        @media (max-width: 380px) {
            .checker {
                width: 22px;
                height: 22px;
            }

            button {
                font-size: 14px;
                padding: 10px 15px;
            }
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="game-info">
            <div class="current-player" id="currentPlayer">Weiss ist am Zug</div>
            <div class="dice-container">
                <div class="die" id="die1">-</div>
                <div class="die" id="die2">-</div>
            </div>
            <div id="moveInfo" style="font-size: 0.9em; margin-top: 5px;"></div>
        </div>

        <div class="board-wrapper">
            <div class="board-container">
                <div class="board" id="board"></div>
                <div class="home white" id="homeWhite"></div>
                <div class="home black" id="homeBlack"></div>
            </div>
        </div>

        <div class="controls">
            <button id="rollDice">Würfeln</button>
            <button id="endTurn">Zug beenden</button>
            <button id="newGame">Neues Spiel</button>
        </div>
    </div>

    <script>
        class BackgammonGame {
            constructor() {
                this.board = Array(24).fill(null).map(() => []);
                this.bar = { white: 0, black: 0 };
                this.home = { white: 0, black: 0 };
                this.currentPlayer = 'white';
                this.dice = [];
                this.availableMoves = [];
                this.selectedPoint = null;
                this.hasRolled = false;
                this.movesMade = 0;
                this.touchStartPoint = null;

                this.initializeBoard();
                this.setupEventListeners();
                this.render();
            }

            initializeBoard() {
                // Standard Backgammon Startposition
                this.board[0] = ['white', 'white'];
                this.board[5] = ['black', 'black', 'black', 'black', 'black'];
                this.board[7] = ['black', 'black', 'black'];
                this.board[11] = ['white', 'white', 'white', 'white', 'white'];
                this.board[12] = ['black', 'black', 'black', 'black', 'black'];
                this.board[16] = ['white', 'white', 'white'];
                this.board[18] = ['white', 'white', 'white', 'white', 'white'];
                this.board[23] = ['black', 'black'];
            }

            setupEventListeners() {
                // Button Events
                document.getElementById('rollDice').addEventListener('click', () => this.rollDice());
                document.getElementById('endTurn').addEventListener('click', () => this.endTurn());
                document.getElementById('newGame').addEventListener('click', () => this.newGame());

                // Touch Events für bessere Mobile-Unterstützung
                document.getElementById('board').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touchStartPoint = this.getPointFromTouch(touch);
                }, { passive: false });

                document.getElementById('board').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.touchStartPoint !== null) {
                        this.handlePointClick(this.touchStartPoint);
                        this.touchStartPoint = null;
                    }
                }, { passive: false });

                // Mouse Events als Fallback
                document.getElementById('board').addEventListener('click', (e) => {
                    const point = this.getPointFromClick(e);
                    if (point !== null) {
                        this.handlePointClick(point);
                    }
                });
            }

            getPointFromTouch(touch) {
                const board = document.getElementById('board');
                const rect = board.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Finde den Punkt basierend auf Koordinaten
                const points = board.querySelectorAll('.point');
                for (let i = 0; i < points.length; i++) {
                    const pointRect = points[i].getBoundingClientRect();
                    if (x >= pointRect.left - rect.left &&
                        x <= pointRect.right - rect.left &&
                        y >= pointRect.top - rect.top &&
                        y <= pointRect.bottom - rect.top) {
                        return parseInt(points[i].dataset.point);
                    }
                }
                return null;
            }

            getPointFromClick(e) {
                const point = e.target.closest('.point');
                if (point) {
                    return parseInt(point.dataset.point);
                }
                return null;
            }

            rollDice() {
                if (this.hasRolled) return;

                const die1 = document.getElementById('die1');
                const die2 = document.getElementById('die2');

                die1.classList.add('rolling');
                die2.classList.add('rolling');

                setTimeout(() => {
                    const roll1 = Math.floor(Math.random() * 6) + 1;
                    const roll2 = Math.floor(Math.random() * 6) + 1;

                    this.dice = roll1 === roll2 ? [roll1, roll1, roll1, roll1] : [roll1, roll2];
                    this.availableMoves = [...this.dice];
                    this.hasRolled = true;

                    die1.textContent = roll1;
                    die2.textContent = roll2;
                    die1.classList.remove('rolling');
                    die2.classList.remove('rolling');

                    this.updateMoveInfo();
                    this.updateButtons();

                    if (roll1 === roll2) {
                        this.showMessage(`Pasch! ${roll1}er Pasch gewürfelt!`);
                    }

                    // Prüfe ob Züge möglich sind
                    if (!this.hasAnyValidMoves()) {
                        this.showMessage('Keine Züge möglich!');
                        setTimeout(() => this.endTurn(), 2000);
                    }
                }, 500);
            }

            canBearOff(player) {
                const homeStart = player === 'white' ? 18 : 0;
                const homeEnd = player === 'white' ? 24 : 6;

                // Prüfen ob alle Steine im Home-Bereich sind
                for (let i = 0; i < 24; i++) {
                    if ((player === 'white' && i < homeStart) ||
                        (player === 'black' && i >= homeEnd)) {
                        if (this.board[i].some(checker => checker === player)) {
                            return false;
                        }
                    }
                }

                // Prüfen ob Steine auf der Bar sind
                return this.bar[player] === 0;
            }

            getValidMoves(fromPoint) {
                const validMoves = [];
                const player = this.currentPlayer;

                // Wenn Steine auf der Bar sind, müssen diese zuerst eingewürfelt werden
                if (this.bar[player] > 0) {
                    if (fromPoint !== 'bar') return [];

                    for (const move of this.availableMoves) {
                        const targetPoint = player === 'white' ? move - 1 : 24 - move;
                        if (this.canMoveTo(targetPoint, player)) {
                            validMoves.push(targetPoint);
                        }
                    }
                    return validMoves;
                }

                if (fromPoint === 'bar') return [];

                const direction = player === 'white' ? 1 : -1;

                for (const move of this.availableMoves) {
                    const targetPoint = fromPoint + (move * direction);

                    // Normaler Zug
                    if (targetPoint >= 0 && targetPoint < 24 && this.canMoveTo(targetPoint, player)) {
                        validMoves.push(targetPoint);
                    }

                    // Bear off
                    if (this.canBearOff(player)) {
                        if ((player === 'white' && targetPoint >= 24) ||
                            (player === 'black' && targetPoint < 0)) {
                            validMoves.push('home');
                        }
                    }
                }

                return validMoves;
            }

            canMoveTo(point, player) {
                if (point < 0 || point >= 24) return false;
                const pointCheckers = this.board[point];
                if (pointCheckers.length === 0) return true;
                if (pointCheckers[0] === player) return true;
                if (pointCheckers.length === 1) return true; // Kann schlagen
                return false;
            }

            makeMove(from, to) {
                const player = this.currentPlayer;
                let moveDistance;

                if (from === 'bar') {
                    this.bar[player]--;
                    moveDistance = player === 'white' ? to + 1 : 24 - to;
                } else if (to === 'home') {
                    const checker = this.board[from].pop();
                    this.home[player]++;
                    moveDistance = player === 'white' ? 24 - from : from + 1;

                    // Prüfe auf Spielende
                    if (this.home[player] === 15) {
                        setTimeout(() => {
                            this.showMessage(`${player === 'white' ? 'Weiss' : 'Schwarz'} hat gewonnen! 🎉`);
                            this.gameOver = true;
                            this.updateButtons();
                        }, 500);
                    }
                } else {
                    const checker = this.board[from].pop();

                    // Gegnerischen Stein schlagen
                    if (this.board[to].length === 1 && this.board[to][0] !== player) {
                        const hitChecker = this.board[to].pop();
                        this.bar[hitChecker]++;
                        this.showMessage(`${hitChecker === 'white' ? 'Weisser' : 'Schwarzer'} Stein geschlagen!`);
                    }

                    this.board[to].push(checker);
                    moveDistance = Math.abs(to - from);
                }

                // Entferne den verwendeten Würfel
                const moveIndex = this.availableMoves.indexOf(moveDistance);
                if (moveIndex > -1) {
                    this.availableMoves.splice(moveIndex, 1);
                }

                this.movesMade++;
                this.selectedPoint = null;
                this.render();
                this.updateMoveInfo();

                // Auto-Ende wenn keine Züge mehr möglich
                if (this.availableMoves.length === 0 || !this.hasAnyValidMoves()) {
                    setTimeout(() => this.endTurn(), 1000);
                }
            }

            hasAnyValidMoves() {
                // Prüfe Bar
                if (this.bar[this.currentPlayer] > 0) {
                    return this.getValidMoves('bar').length > 0;
                }

                // Prüfe alle Punkte
                for (let i = 0; i < 24; i++) {
                    if (this.board[i].some(checker => checker === this.currentPlayer)) {
                        if (this.getValidMoves(i).length > 0) {
                            return true;
                        }
                    }
                }

                return false;
            }

            handlePointClick(pointIndex) {
                if (!this.hasRolled || this.gameOver) return;

                if (this.selectedPoint === null) {
                    // Auswahl eines Steins
                    if (this.board[pointIndex].some(checker => checker === this.currentPlayer)) {
                        if (this.bar[this.currentPlayer] > 0) {
                            this.showMessage('Zuerst müssen Steine von der Bar eingewürfelt werden!');
                            return;
                        }
                        this.selectedPoint = pointIndex;
                        this.render();
                    }
                } else if (this.selectedPoint === pointIndex) {
                    // Abwahl
                    this.selectedPoint = null;
                    this.render();
                } else {
                    // Zug ausführen
                    const validMoves = this.getValidMoves(this.selectedPoint);
                    if (validMoves.includes(pointIndex)) {
                        this.makeMove(this.selectedPoint, pointIndex);
                    } else {
                        // Neue Auswahl
                        if (this.board[pointIndex].some(checker => checker === this.currentPlayer)) {
                            this.selectedPoint = pointIndex;
                            this.render();
                        }
                    }
                }
            }

            handleBarClick() {
                if (!this.hasRolled || this.gameOver) return;

                if (this.bar[this.currentPlayer] > 0) {
                    this.selectedPoint = 'bar';
                    this.render();
                }
            }

            handleHomeClick(color) {
                if (!this.hasRolled || this.gameOver) return;
                if (color !== this.currentPlayer) return;

                if (this.selectedPoint !== null && this.selectedPoint !== 'bar') {
                    const validMoves = this.getValidMoves(this.selectedPoint);
                    if (validMoves.includes('home')) {
                        this.makeMove(this.selectedPoint, 'home');
                    }
                }
            }

            endTurn() {
                if (!this.hasRolled || this.gameOver) return;

                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.dice = [];
                this.availableMoves = [];
                this.hasRolled = false;
                this.movesMade = 0;
                this.selectedPoint = null;

                document.getElementById('currentPlayer').textContent =
                    `${this.currentPlayer === 'white' ? 'Weiss' : 'Schwarz'} ist am Zug`;

                this.render();
                this.updateButtons();
                this.updateMoveInfo();
            }

            updateMoveInfo() {
                const moveInfo = document.getElementById('moveInfo');
                if (this.availableMoves.length > 0) {
                    moveInfo.textContent = `Verfügbare Züge: ${this.availableMoves.join(', ')}`;
                } else {
                    moveInfo.textContent = '';
                }
            }

            updateButtons() {
                document.getElementById('rollDice').disabled = this.hasRolled || this.gameOver;
                document.getElementById('endTurn').disabled = !this.hasRolled || this.gameOver;
            }

            showMessage(text) {
                const existing = document.querySelector('.message');
                if (existing) existing.remove();

                const message = document.createElement('div');
                message.className = 'message';
                message.textContent = text;
                document.body.appendChild(message);

                setTimeout(() => message.remove(), 2500);
            }

            newGame() {
                this.board = Array(24).fill(null).map(() => []);
                this.bar = { white: 0, black: 0 };
                this.home = { white: 0, black: 0 };
                this.currentPlayer = 'white';
                this.dice = [];
                this.availableMoves = [];
                this.selectedPoint = null;
                this.hasRolled = false;
                this.movesMade = 0;
                this.gameOver = false;

                this.initializeBoard();
                this.render();
                this.updateButtons();
                this.updateMoveInfo();

                document.getElementById('currentPlayer').textContent = 'Weiss ist am Zug';
                document.getElementById('die1').textContent = '-';
                document.getElementById('die2').textContent = '-';
            }

            render() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';

                // Obere Reihe (Points 12-23)
                // Linke Hälfte (12-17)
                for (let i = 12; i < 18; i++) {
                    this.renderPoint(i, 'top', boardElement);
                }

                // Bar (obere Hälfte)
                const barTop = document.createElement('div');
                barTop.className = 'bar';
                barTop.style.gridRow = '1';
                boardElement.appendChild(barTop);

                // Rechte Hälfte (18-23)
                for (let i = 18; i < 24; i++) {
                    this.renderPoint(i, 'top', boardElement);
                }

                // Untere Reihe (Points 11-0)
                // Linke Hälfte (11-6)
                for (let i = 11; i >= 6; i--) {
                    this.renderPoint(i, 'bottom', boardElement);
                }

                // Bar (untere Hälfte)
                const barBottom = document.createElement('div');
                barBottom.className = 'bar';
                barBottom.style.gridRow = '2';

                // Bar-Inhalte hinzufügen
                if (this.bar.white > 0) {
                    for (let i = 0; i < this.bar.white; i++) {
                        const checker = this.createChecker('white');
                        barBottom.appendChild(checker);
                    }
                }
                if (this.bar.black > 0) {
                    for (let i = 0; i < this.bar.black; i++) {
                        const checker = this.createChecker('black');
                        barTop.appendChild(checker);
                    }
                }

                if (this.selectedPoint === 'bar' && this.bar[this.currentPlayer] > 0) {
                    if (this.currentPlayer === 'white') {
                        barBottom.classList.add('selected');
                    } else {
                        barTop.classList.add('selected');
                    }
                }

                barTop.addEventListener('click', () => this.handleBarClick());
                barBottom.addEventListener('click', () => this.handleBarClick());
                boardElement.appendChild(barBottom);

                // Rechte Hälfte (5-0)
                for (let i = 5; i >= 0; i--) {
                    this.renderPoint(i, 'bottom', boardElement);
                }

                // Home-Bereiche rendern
                this.renderHome();
            }

            renderPoint(index, position, container) {
                const point = document.createElement('div');
                point.className = `point ${position}`;
                point.dataset.point = index;

                if (this.selectedPoint === index) {
                    point.classList.add('selected');
                }

                if (this.selectedPoint !== null) {
                    const validMoves = this.getValidMoves(this.selectedPoint);
                    if (validMoves.includes(index)) {
                        point.classList.add('valid-move');
                    }
                }

                const checkers = this.board[index];
                const maxVisible = 5;

                checkers.forEach((color, i) => {
                    if (i < maxVisible) {
                        const checker = this.createChecker(color);
                        point.appendChild(checker);
                    }
                });

                if (checkers.length > maxVisible) {
                    const counter = document.createElement('div');
                    counter.className = 'counter';
                    counter.textContent = checkers.length;
                    point.appendChild(counter);
                }

                container.appendChild(point);
            }

            renderHome() {
                const homeWhite = document.getElementById('homeWhite');
                const homeBlack = document.getElementById('homeBlack');

                homeWhite.innerHTML = '';
                homeBlack.innerHTML = '';

                // Rendere nur die ersten paar Steine visuell
                const maxVisible = 7;

                for (let i = 0; i < Math.min(this.home.white, maxVisible); i++) {
                    const checker = this.createChecker('white');
                    homeWhite.appendChild(checker);
                }

                if (this.home.white > maxVisible) {
                    const counter = document.createElement('div');
                    counter.className = 'counter';
                    counter.textContent = this.home.white;
                    homeWhite.appendChild(counter);
                }

                for (let i = 0; i < Math.min(this.home.black, maxVisible); i++) {
                    const checker = this.createChecker('black');
                    homeBlack.appendChild(checker);
                }

                if (this.home.black > maxVisible) {
                    const counter = document.createElement('div');
                    counter.className = 'counter';
                    counter.textContent = this.home.black;
                    homeBlack.appendChild(counter);
                }

                if (this.selectedPoint !== null && this.canBearOff(this.currentPlayer)) {
                    const validMoves = this.getValidMoves(this.selectedPoint);
                    if (validMoves.includes('home')) {
                        if (this.currentPlayer === 'white') {
                            homeWhite.classList.add('valid-move');
                        } else {
                            homeBlack.classList.add('valid-move');
                        }
                    }
                }

                homeWhite.addEventListener('click', () => this.handleHomeClick('white'));
                homeBlack.addEventListener('click', () => this.handleHomeClick('black'));
            }

            createChecker(color) {
                const checker = document.createElement('div');
                checker.className = `checker ${color}`;
                if (color === this.currentPlayer && this.hasRolled) {
                    checker.classList.add('draggable');
                }
                return checker;
            }
        }

        // Spiel starten
        const game = new BackgammonGame();

        // Verhindere Zoom auf Doppeltipp
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Verhindere Scrollen
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>

</html>